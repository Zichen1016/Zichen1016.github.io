<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="jquery-3.4.1.js"></script>
    <script type="text/javascript">
    //一切都是对象
    //值类型
    /* console.log(typeof x);
    console.log(typeof 10);   // number
    console.log(typeof 'abc'); // string
    console.log(typeof true);  // boolean*/
    // 对象
    /* console.log(typeof function () {});  //function 函数
    console.log(typeof [1, 'a', true]);  //object 数组
    console.log(typeof { a: 10, b: 20 });  //object 对象
    console.log(typeof null);  //object null
    console.log(typeof new Number(10));  //object new Number(10) */
    //判断一个变量是不是对象
    /* var fn = function () { };
    fn = [1, 2];
    console.log(fn instanceof Object);  // true
    fn = 'abc';
    console.log(fn instanceof Object);  // false
    fn = null;
    console.log(fn instanceof Object);  // false
    fn = new Number(10);
    console.log(fn instanceof Object); //true */
    //对象中只有属性
   /*  var obj = {
        a: 10,
        b: function (x) {
            alert(this.a + x);
        },
        c: {
            name: '张三',
            year: 3
        }
    };
    console.log(obj);
    console.log(obj.b(1));//->11 */
    //函数也是属性的集合
    /* var fn = function () {
            alert(100);
        };
        fn.a = 10;
        fn.b = function () {
            alert(123);
        };
        fn.c = {
            name: "李四",
            year: 4
        };
        console.log(fn());//->100 ->undefined
        console.log(fn.a);//->10
        console.log(fn.b());//->123 ->undefined
        console.log(fn.c);//->{name: "李四", year: 4} */
        //使用jQuery源码 函数赋予了属性
        /* console.log(typeof $);  // function 函数
        console.log($.trim(" ABC "));//->ABC trim截取前后空格 */
        // 对象可以通过函数来创建
        /* function Fn() {
            this.name = '王福朋';
            this.year = 1988;
        }
        var fn1 = new Fn();
        console.log(fn1);//->Fn {name: "王福朋", year: 1988} */
        //对象都是通过函数创建的
        //var obj = { a: 10, b: 20 };
        /* var obj = new Object();
        obj.a = 10;
        obj.b = 20;
        console.log(obj);
        //var arr = [5, 'x', true];
        var arr = new Array();
        arr[0] = 5;
        arr[1] = 'x';
        arr[2] = true;
        console.log(arr);
        //而其中的 Object 和 Array 都是函数：
        console.log(typeof (Object));  // function
        console.log(typeof (Array));  // function */
        //prototype(原型)
        /*每个函数都有一个属性叫做prototype,prototype的属性值是一个对象，
        默认的只有一个叫做constructor的属性，constructor指向这个函数本身。*/
        /* function a() {
            console.log(1);
        }
        console.log(typeof a.prototype);//-> oobject
        console.log(a===a.prototype.constructor);//-> true
        console.log(a.prototype);//-> {constructor: ƒ}
        console.log(a.prototype.constructor);//-> ƒ a(){console.log(1);} */
        //在自己自定义的方法的prototype中新增自己的属性
        /* function a() {
            console.log(1);
        }
        a.prototype.name = '张三';
        a.prototype.getYear = function () {
            return 3;
        };
        console.log(a.prototype.name);//-> 张三
        console.log(a.prototype.getYear());//-> 3 */
        /* var $div = $('div');//$('div')返回的是一个对象
        console.log($div.attr('myName', '张三')); */
        //fn对象调用Fn.prototype中的属性
        /* function Fn() { }
        Fn.prototype.name = '李四';
        Fn.prototype.getYear = function () {
            return 4;
        };
        var fn = new Fn();//fn对象 */
        /* 每个对象都有一个隐藏的属性 __proto__ ，这个属性引用了创建
        这个对象的函数的prototype。 "__proto__"成为“隐式原型”*/
        /* console.log(fn.name);//-> 李四
        console.log(fn.getYear());//-> 4
        console.log(fn.__proto__.name);//-> 李四
        console.log(fn.__proto__.getYear());//-> 4
        console.log(fn.__proto__ === Fn.prototype);//__双下划线 true
        var obj = new Object;
        console.log(obj.__proto__ === Object.prototype);//-> true */




        //执行上下文(环境)
        /* 在一段js代码拿过来真正一句一句运行之前，浏览器已经
        做了一些“准备工作”，其中就包括对变量的声明，而不是赋
        值。变量赋值是在赋值语句执行的时候进行的。 */
        /* console.log(a);//-> a is not defined */
        /* console.log(a);//->undefined 准备工作：对变量声明
        var a;
        a = 10;
        console.log(a);//-> 10 */
        /* 在“准备工作”中，对待函数表达式就像对待“ var a =
        10 ”这样的变量一样，只是声明。而对待函数声明时，却
        把函数整个赋值了。 */
        /* console.log(this);//准备工作:直接给this赋值
        console.log(f1);//-> ƒ f1() { }
        function f1() { }//函数声明
        console.log(f2);//-> undefined
        var f2 = function () { };//函数表达式 */
        /* var a = 'abc';
        console.log((Boolean)(a));//-> true
        console.log(!a);//-> fallse
        a = !!a;//非非为原本 
        console.log(a);//-> true */
        /* 函数每被调用一次，都会产生一个新的执行上下文环境。
        因为不同的调用可能就会有不同的参数。 */
        /* function fn(x) {
            console.log(arguments);//-> Arguments [10, callee: ƒ, Symbol(Symbol.iterator): ƒ]
            console.log(x);//-> 1 11
        }
        fn(1);//1
        fn(11);//11 */
        /* 函数在定义的时候（不是调用的时候），就已经确定了函
        数体内部自由变量的作用域。 */
        var a = 10;
        function fn() {
            console.log(a);
        }

        function bar(f) {
            var a = 20;
            f();
        }
        bar(fn);//-> 10
</script>
</head>
<body>
    
</body>
</html>